// –í –Ω–µ–∫–æ–º –∫–æ—Ä–æ–ª–µ–≤—Å—Ç–≤–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å–µ—Ç—å –¥–æ—Ä–æ–≥ –º–µ–∂–¥—É –≥–æ—Ä–æ–¥–∞–º–∏, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–∞—è –≤ –≤–∏–¥–µ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞. –ò–∑-–∑–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –º–µ—Å—Ç–Ω–æ–≥–æ –∫–ª–∏–º–∞—Ç–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Ä–æ–≥–∏ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω–µ–≤–∏–¥–∏–º—ã–º–∏: –æ–Ω–∏ –µ—Å—Ç—å, –Ω–æ –∏—Ö –Ω–µ –≤–∏–¥–Ω–æ –Ω–∞ –∫–∞—Ä—Ç–µ. –¢–µ–º –Ω–µ –º–µ–Ω–µ–µ, –∂–∏—Ç–µ–ª–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –º–æ–≥—É—Ç –ø–æ –Ω–∏–º –ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è.
// –í–∞–º –∏–∑–≤–µ—Å—Ç–Ω—ã –≤—Å–µ –≥–æ—Ä–æ–¥–∞ (–≤–µ—Ä—à–∏–Ω—ã) –∏ —Ç–æ–ª—å–∫–æ —Ç–µ –¥–æ—Ä–æ–≥–∏, –∫–æ—Ç–æ—Ä—ã–µ –æ—Å—Ç–∞–ª–∏—Å—å –≤–∏–¥–∏–º—ã–º–∏ (—Ä—ë–±—Ä–∞). –ö —Å—á–∞—Å—Ç—å—é, –≤—ã —Ç–∞–∫–∂–µ –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –≤—Å–µ –≥–æ—Ä–æ–¥–∞ –±—ã–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω—ã —Ç–∞–∫, —á—Ç–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –¥–æ–±—Ä–∞—Ç—å—Å—è –æ—Ç –ª—é–±–æ–≥–æ –≥–æ—Ä–æ–¥–∞ –¥–æ –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ.
// –ö–∞–∫–æ–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—Ä–æ–≥ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ ¬´–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å¬ª, —á—Ç–æ–±—ã –≤–Ω–æ–≤—å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–≤—è–∑–Ω–æ—Å—Ç—å –≤—Å–µ–π –∫–∞—Ä—Ç—ã?
//
// –í—Ö–æ–¥:
// –í–µ—Ä—à–∏–Ω—ã: A, B, C, D, E
// –í–∏–¥–∏–º—ã–µ —Ä—ë–±—Ä–∞:
// A B
// C D
//
// –í—ã—Ö–æ–¥:
// –í –≥—Ä–∞—Ñ–µ 3 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–≤—è–∑–Ω–æ—Å—Ç–∏: {A, B}, {C, D}, {E}
// –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –º–∏–Ω–∏–º—É–º 2 —Ä–µ–±—Ä–∞, —á—Ç–æ–±—ã —Å–æ–µ–¥–∏–Ω–∏—Ç—å –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã.
//
// üí°–ü–æ–¥—Å–∫–∞–∑–∫–∞:
// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö —Ä—ë–±–µ—Ä –¥–ª—è —Å–≤—è–∑–Ω–æ—Å—Ç–∏ = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏ ‚àí 1.

#include <iostream>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

class SimpleGraph {
private:
    map<string, vector<string>> adjList;
    set<string> allVertices;

public:
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—à–∏–Ω—ã
    void addVertex(const string& v) {
        allVertices.insert(v);
        if (adjList.find(v) == adjList.end())
            adjList[v] = {};
    }
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ (–Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≥—Ä–∞—Ñ)
    void addEdge(const string& u, const string& v) {
        addVertex(u);
        addVertex(v);
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }
    // –ü–æ–∏—Å–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é BFS
    int countConnectedComponents() {
        set<string> visited;
        int components = 0;
        for (const string& vertex : allVertices) {
            if (visited.find(vertex) == visited.end()) {
                components++;
                bfs(vertex, visited);
            }
        }
        return components;
    }
    // BFS –¥–ª—è –æ–±—Ö–æ–¥–∞ –æ–¥–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
    void bfs(const string& start, set<string>& visited) {
        queue<string> q;
        q.push(start);
        visited.insert(start);
        while (!q.empty()) {
            string current = q.front();
            q.pop();
            for (const string& neighbor : adjList[current]) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }
};

void runTest(const vector<string>& vertices, const vector<pair<string, string>>& edges) {
    SimpleGraph g;
    // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã
    for (const string& v : vertices)
        g.addVertex(v);
    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –≤–∏–¥–∏–º—ã–µ —Ä—ë–±—Ä–∞
    for (const auto& e : edges)
        g.addEdge(e.first, e.second);
    // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏
    int components = g.countConnectedComponents();
    int toRestore = components - 1;
    cout << "Connected components: " << components << endl;
    cout << "Minimum edges to restore: " << toRestore << endl;
    cout << "-------------------------------------------\n";
}

int main() {
    cout << "--- Test 1: Simple 5-node graph with 2 edges ---\n";
    runTest(
        {"A", "B", "C", "D", "E"},
        {{"A", "B"}, {"C", "D"}}
    );
    cout << "--- Test 2: Fully connected graph ---\n";
    runTest(
        {"A", "B", "C"},
        {{"A", "B"}, {"B", "C"}, {"C", "A"}}
    );
    cout << "--- Test 3: No edges at all ---\n";
    runTest(
        {"X", "Y", "Z"},
        {}
    );
    cout << "--- Test 4: Two isolated nodes + connected chain ---\n";
    runTest(
        {"A", "B", "C", "D", "E"},
        {{"A", "B"}, {"B", "C"}}
    );
    cout << "--- Test 5: Already tree (connected, no cycle) ---\n";
    runTest(
        {"A", "B", "C", "D"},
        {{"A", "B"}, {"A", "C"}, {"C", "D"}}
    );
    return 0;
}
